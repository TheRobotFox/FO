* Project
- Fun little Visualization of Graphs constrained by Predicatelogical Formulars
- Visualisation using [[https://www.raylib.com/][Raylib]]
- Parsing made with [[https://github.com/TheRobotFox/MLCC][MLCC]] (very WIP)
  [[file:img.png]]
** Usage
** Compilation
*** Raylib Project
To Compile this Project you'll need the following
- C++ Compiler (tested using g++ 14.2.1)
- TBB support (included in g++)
- Raylib with C bindings
Then just run this Command to build the Project
#+begin_src sh
g++ main.cpp Graph.cpp -std=c++26 -fsanitize=address -ggdb -lraylib -ltbb
#+end_src
*** Building the Parser
The [[file:parse.cpp][Parser]] is being generated by [[https://github.com/TheRobotFox/MLCC][MLCC]] using a [[file:fo.g][Grammarspec]].
MLCC is still in very early development so it's still a little hard to work with, since atm all paths are hard-coded
and the code generation has also been 'adjusted' for this project (mainly because MLCC does not have it's own lexer yet).
If you're still up for it get it from [[https://github.com/TheRobotFox/MLCC][here]] (commit 8b8694f has most things set-up). Follow these steps:
- Navigate $src/$ Directory and open $main.rs$
- inside $main:85$
  #+begin_src rust
  let source = match read_to_string("fo.g") { // <-- Path to Grammarspec
        Ok(s) => s,
        Err(e) => {
            panic!("cannot read file!")
        }
    };
  #+end_src
- $main:137$
  #+begin_src rust
let output = reverseparse::export_cpp(&automaton); // <-- Code Generator (see reverseparse.rs)
    let mut file = match File::create("../FO/parse.cpp") { // <-- Code generation output Path
    // let mut file = match File::create("../parser/src/main.rs") {
        Err(e) => panic!("Could not open file: {:?}", e),
        Ok(f) =>f
    };

  #+end_src
- Compile and run via src_sh[:exports code :eval never]{cargo run}

After this the Parser should have been regenerated at the specified location, because MLCC does not currently have a built-in Lexer
i have handcrafted one for very very basic use cases. It can
- Parse any number of distinct Keywords
- Identifiers of thr Form $[A-Za-z_]+$
- Skip space character (no other whitespace)
Building a one Regex was not on my mind that day, sorry about that...

To make the Parser work you'll have to open it up and tell it which Token is the special Regex Identifier Token

When you open the generated Parser it will look smth like this
#+begin_src cpp
struct Token {
    enum Kind {
		//EOF
		Tok0=0,
		//Regex: "[a-zA-Z]+"
		Tok1=1,
		//Token: "\a"
		Tok2=2,
   ...
#+end_src
You can see the Regex $[a-zA-Z]+$ is above $Tok1$
If you scroll down to the src_cpp[:exports code :eval never]{auto read_token(...) -> int} at the end, after the keyword matching there's this code
#+begin_src cpp
    ...
    const auto *iter = str.begin();
    while((isalnum(*iter) != 0) || *iter=='_') iter++;
    v.emplace_back(Token::Tok?, std::string_view(str.begin(),iter));
    return iter-str.begin();
}
#+end_src
All you have to do is replace the $Token::Tok?$ with the Identifier Token eg. $Token::Tok2$ in the above case.
Now you're all set!
I might update this page once MLCC is actually usable, but it was very cool to finally use it on an Project and i still think it
was easier/faster than building the parser from Scratch. I've done that may to often by now...



** [ ] Goals
*** [X] Generate Random Graphs
*** [X] Enter Formular to constrain Graph
*** [X] Random collapse based on Contrains
*** [ ] Formula Feedback
*** [ ] Performance
*** KILL Graph viz <- Dependency
